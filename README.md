Djaq: Django Queries
====================

Copyright (c) Paul Wolf

Djaq provides an alternative query language to QuerySets guided by a different set of targeted behaviours intended to force the developer to be explicit about what she wants to do and provide the fastest possible retrieval methods using the clearest possible expression. Here's an example:

    DQ("""(b.name,
           b.price as price,
	       0.2 as discount,
	       b.price*0.2, as discount_price, 
           b.price - (b.price*0.2) as diff
          ) Book{b.price > 50} b""")

This will return results with name, price, discount, discount_price, diff fields for books that cost more than 50. 

The Django ORM is a great tool for database access. But it is driven by a specific set of choices about how to use the ORM. The main thrust of Querysets is automagic access to related data. It's easy to perform many operations with little code and no knowledge of SQL. For these goals, it is excellent. But committing to a set of target behaviours entails tradeoffs:

* Unnatural query formulation: The notation for QuerySets, like filtering can appear obscure and verbose.
* Inefficient queries: the default sql generated by simple Querysets is not always the most efficient. 
* Inadvertently inefficent database usage: Because QuerySets do such a great job hiding complexity, they often hide important consequences of patterns that can produce massively slow code. Mainly this exhibits when iterating the result of a queryset when the developer does not notice that an operation on a Model instance is causing a new query for every iteration. 
* Obscure access to features like complex column expressions, subqueries, etc. F expressions, Outterefs, and other features are powerful but they can seem arcane and hard to understand.

Some important notes before you try it: 

* Djaq sits on top of Django Models. It is an alternative to the Django Queryset class and it only works with Django Models at this time. 
* It is entirely compatible with QuerySets being used in the same application.
* Djaq only enables queries. It does not provide data update features, like creating new objects or modifying existing ones. 
* It's a work-in-progress. It is not refined or tested enough to use in a production environment. 

Reasons why Djaq might be a reasonable alternative to Querysets for some use cases:

* More natural query formulation using a Python-like syntax
* More fine-grained control of result sets
* Eschew laziness: don't trigger queries on behalf of the user except just once in an explicit and predictable manner
* Default to cursor semantics rather than sliceable lists of objects for better performance

##Requirements

* Django 2.1 or higher
* Postgresql 

To Install:

    pip install Djaq

This will install it into your Django project, probably into your virtual environment.

Sample Project
--------------

If you want to use Djaq right away in your own test project and you feel confident, crack on. In that case skip the following instructions for using the sample project. There is a sample Django project, `bookshop`. If you want to try this, clone the django repo:

    git clone git@github.com:paul-wolf/djaq.git
    cd djaq/bookshop

If you clone the repo and use the sample project, you don't need to
include Djaq as a requirement because it's included as a module by a
softlink. Create the virtualenv:

    virtualenv -p python3 .venv    

Activate the virtual environment:

    source .venv/bin/activate

The module itself does not install Django and there are no further
requirements. To install dependencies for the sample application:

    pip install -r requirements.txt

Now make sure there is a Postgresql instance running. The settings are like this:

```
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.postgresql_psycopg2',
        'NAME': 'bookshop',
    },
```
	
So, it assumes peer authentication. Now you can migrate. Make sure the virtualenv is activated! 


    ./manage.py migrate

We provide a script to create some sample data:

    ./manage.py build_data --book-count 2000

This creates 2000 books and associated data. 


The example app comes with a management command to run
queries:

    ./manage.py djaq "(Publisher.name, max(Book.price) - round(avg(Book.price)) as diff) Book b"  --format json

If using in code, you would do this:

    from djaq import DjangoQuery as DQ
	dq = DQ("(avg(b.price) as average_book_price) Book b"
	str(dq)

There are several generators to choose from to iterate records:

    DjangoQuery.json()  # return json objects
    DjangoQuery.dicts() # dicts
    DjangoQuery.tuples() # tuples of values
    DjangoQuery.objs()  # We return for each record, an instance of XQueryInstance

The DQResult is a namespace for results:

    for result in DQ('(Book.name, Book.price)').objs():
        print(result.name)
        print(result.price)

etc.

Output of the command should look like this:

```
â–¶ ./manage.py djaq "(Publisher.name, max(Book.price) - round(avg(Book.price)) as diff) Book b"  --format json
SELECT books_publisher.name, (max(books_book.price) - round(avg(books_book.price))) FROM books_book LEFT JOIN books_publisher ON (books_book.publisher_id = books_publisher.id)  GROUP BY books_publisher.name LIMIT 10
{"publisher_name": "Avila, Garza and Ward", "diff": 14.0}
{"publisher_name": "Boyer-Clements", "diff": 16.0}
{"publisher_name": "Clark, Garza and York", "diff": 15.0}
{"publisher_name": "Clarke PLC", "diff": 14.0}
{"publisher_name": "Griffin-Blake", "diff": 16.0}
{"publisher_name": "Hampton-Davis", "diff": 13.0}
{"publisher_name": "Jones LLC", "diff": 15.0}
{"publisher_name": "Lane-Kim", "diff": 15.0}
{"publisher_name": "Norris-Bennett", "diff": 14.0}
{"publisher_name": "Singleton-King", "diff": 17.0}
```

Notice the SQL used to retrieve data is printed first. 

Here are some examples comparing Djaq to QuerySets. Note that throughout, I will use the exact models provided as examples here: https://docs.djangoproject.com/en/2.1/topics/db/aggregation/. For convenience: 

```
from django.db import models

class Author(models.Model):
    name = models.CharField(max_length=100)
    age = models.IntegerField()

class Publisher(models.Model):
    name = models.CharField(max_length=300)

class Book(models.Model):
    name = models.CharField(max_length=300)
    pages = models.IntegerField()
    price = models.DecimalField(max_digits=10, decimal_places=2)
    rating = models.FloatField()
    authors = models.ManyToManyField(Author)
    publisher = models.ForeignKey(Publisher, on_delete=models.CASCADE)
    pubdate = models.DateField()

class Store(models.Model):
    name = models.CharField(max_length=300)
    books = models.ManyToManyField(Book)
```

Let's compare getting all the books and iterating over them:

    # get all books with a QuerySet
    qs = Book.objects.all()
    for book in qs:
        print(book)
        
    # get all books with Djaq
    dq = DQ("(b.id, b.name) Book b")
    for book in xq.tuples():
        print(book)

Notice, with Djaq we provided explicit fields that we want returned. It might look slightly more complicated but in fact most queries are less verbose in Djaq:

    # Get average price of books 
    from django.db.models import Avg
    Book.objects.all().aggregate(Avg('price'))
    
    {'price__avg': 18.466780449193628}
    
    # average price using Djaq
    DQ("(avg(b.price)) Book b").value()
    
    Decimal('18.4667804491936282')


The full syntax for Djaq queries:


    (<field_exp1>, ...) <ModelName>{<filter_expression>} <alias> order by (<field_exp1>, ...)

This expression is a string passed as the first argument when creating a DjangoQuery object. In our examples we import under the alias `DQ`:

    from djaq import DjangoQuery as DQ

For QuerySet examples, we assume imports like this: 

    from django.db.models import Q, Avg, Count, Min, Max, Sum, FloatField, Subquery, OuterRef
    from books.models import Author, Publisher, Book, Store

With Djaq, you don't need to import Count, Sum, Min, etc. or the Model classes. Count books:

    dq = DQ("(count(Book.id)) Book")

We can get the result in numerous ways:

    DQ("(count(Book.id)) Book").value()

Or use an iterator:

    for t in DQ("(count(Book.id)) Book").tuples():
        print(t)

The reason for Djaq is to target a different set of concerns about data retrieval rather than try to be better than the QuerySet class. There are pros and cons to both. Very few queries in Djaq cannot be produced in QuerySets although mostly the Djaq syntax is more straightforward. The Djaq syntax is more unified whereas QuerySets require a somewhat sprawling set of techniques like aggregate(), Q() expressions and `F()` expressions to give access to complex column expressions. 

Let's quickly run through a set of examples comparing Djaq XQueries to QuerySets. 

Get the average price of books:

    DQ("(avg(b.price)) Book b")

compared to:

    Book.objects.all().aggregate(Avg('price'))

Get the difference off the maximum price: 

    DQ("(Publisher.name, max(Book.price) - avg(Book.price) as price_diff) Book b")
    
compared to:

    Book.objects.aggregate(price_diff=Max('price', output_field=FloatField()) - Avg('price'))

Count books per publisher:

    DQ("(Publisher.name, count(Book.id) as num_books) Book b")

compared to:

    Publisher.objects.annotate(num_books=Count("book"))

Count books with ratings up to and over 5:

    DQ("""(sum(iif(b.rating < 5, b.rating, 0)) as below_5, 
        sum(iif(b.rating >= 5, b.rating, 0)) as above_5) 
        Book b""")

compared to:

    above_5 = Count('book', filter=Q(book__rating__gt=5))
    below_5 = Count('book', filter=Q(book__rating__lte=5))
    Publisher.objects.annotate(below_5=below_5).annotate(above_5=above_5)

Get average, maximum, minimum price of books:

    DQ("(avg(b.price), max(b.price), min(b.price)) Book b")

compared to:

    Book.objects.aggregate(Avg('price'), Max('price'), Min('price'))

The DjangoQuery class comes with these generators:

`tuples()`: return tuples
`json()`: return json representation of each result row
`dicts()`: return a dict for each result row
`csv()`: return a csv respresentation of the result row

Just as there is a ModelInstance class in Django, we have a DQResult class:

`objs()`: return a DQResult for each result row, basically a namespace for the object:

```
dq = DQ("(b.id, b.name, Publisher.name as publisher) Book b")
for book in xq.objs():
    title = book.name
    publisher = book.publisher
    ...
```

Note that by default, you iterate using a generator. You cannot slice a generator. 

Some other features:

`DjangoQuery.value()`: when you know the result is a single row with a single value, you can immediately access it without further iterations:

    DQ("(count(Book.id)) Book{}").value()

will return a single integer value representing the count of books. 

Comparing features
------------------

Unsurprisingly, Django provides significant options for adjusting query generation to fit a use case, `only()`, `select_related()`, `prefetch_related()` are all highly useful for different cases. Here's a point-by-point comparison with Djaq:

* only(): Djaq always works in "only" mode. Only explicitly requested fields are returned.
* select_related: The select clause only returns those columns explicitly defined. This feature makes loading of related fields non-lazy. But all queries are non-lazy in Djaq.
* prefetch_related: this is not really a job for Djaq. Currently, there is no support for m2m fields but when this is implemented, it will be part of the instance manager.  
* F expressions: These are workarounds for not being able to write expressions in the query for things like column value arithmetic and other expressions you want to have the db calculate. Djaq let's you write these directly and naturally as part of it's syntax.
* Subquery and Outteref: Djaq does not require extra imports or syntactic sugar to express subqueries.
* To aggregate with Querysets, you use `aggregate()`, whereas with Djaq aggregate results are natively part of the result set.
* Model instances with QuerySets exactly represent the corresponding Django model. Djaq has a different concept of a result instance (DQResult) that represents whatever is returned by the query even if it's not a model field. 

Djaq does not try to hide as much about the underlying data structures as Querysets. Djaq does less to hide underlying SQL features. I think there are two types of django developer those who design a data schema and then design Django models to embody that and those who write Django models and let Django take care of the underlying schema. It may be the former type of Django developer will be more drawn to Djaq.

Results vs Model Instances
--------------------------

The Djaq generator `.objs()` returns a `DQResult` class instance. Djaq produces 'results' in contrast to model instances. Depending on what methods you use on QuerySets you may get Django Model instances or a list or a dict, etc. Djaq never returns a model instance. But you can easily get a model instance via the DQResult. 

Functions
---------

In the following: 

    DQ("(b.name) Book{like(upper(b.name), upper('$(name_search)'))} b")

`like()` is a Djaq-defined function that is converted to `field LIKE string`. Whereas `upper()` is sent to the underlying database because it's a common SQL function. Any function can be created or existing functions mutated by updating the `DjangoQuery.functions` dict where the key is the upper case function name and the value is a template string with `{}` placeholders. Arguments are positionally interpolated. 

Above, we provided this example:

   DQ("""(
    sum(iif(b.rating < 5, b.rating, 0)) as below_5, 
    sum(iif(b.rating >= 5, b.rating, 0)) as above_5
    ) Book b""")
        
We can simplify further by creating a new function. The IIF function is defined like this: 

    "CASE WHEN {} THEN {} ELSE {} END"
 
 We can create a `SUMIF` function like this: 
 
    DjangoQuery.functions['SUMIF'] = "SUM(CASE WHEN {} THEN {} ELSE {} END)"
 
 Now we can rewrite the above like this: 
 
    DQ("""(
        sumif(b.rating < 5, b.rating, 0) as below_5, 
        sumif(b.rating >= 5, b.rating, 0) as above_5
        ) Book b""")

Parameters
----------

We call the Django connection cursor approximately like this: 

    from django.db import connections
    cursor = connections['default']
    cursor.execute(sql, context_dict)

When we execute the resulting SQL query, named parameters are used. You *must* name your parameters. Positional parameters are not passed: 

    oldest = '2000-01-01'
    DQ("(b.id) Book{b.pub_date >= '$(oldest)'} b").context({"oldest": oldest}).tuples()

Notice that any parameterised value must be represented in the query expression in single quotes: 

    '$(myparam)'

Therefore, when you add subqueries, their parameters have to be supplied at the same time. 

Note what is happening here: 

    name_search = 'Bar.*'
    DQ("(b.id) Book{regex(b.name, '%(name_search)')} b").context(locals()).tuples()

To get all books starting with 'Bar'. Or:

    DQ("(b.name) Book{like(upper(b.name), upper('$(name_search)'))} b").context(request.POST)

Provided that `request.POST` has a `name_search` key/value. 

Column expressions
------------------

Doing column arithmetic is much more natural and does not require the voodoo of F expressions: 

    # QuerySet
    Book.objects.all()
                .annotate(discount=0.2)
                        .annotate(price=Sum('price'))
                        .annotate(discount_price=F('price') * F('discount')
                        .annotate(diff=F('price') - F('discount_price')) 



    # Djaq
    DQ("""(b.name,
        b.price as price,
        0.2 as discount,
        b.price*0.2 as discount_price, 
        b.price - (b.price*0.2) as diff
        ) Book b""")

Subqueries and IN clause
------------------------

You can reference subqueries within a Djaq expression using

* Another DjangoQuery
* A Queryset
* A list

You can use an IN clause with the keyword `in` (note lower case). Create one DjangoQuery and reference it with `@queryname`:

    DQ("(b.id) Book{name == 'B*'} b", name='xq_sub')
    dq = DQ("(b.name, b.price) Book{id in '@xq_sub'} b")

Note that you have to pass a name to the DjangoQuery to reference it later. We can also use the `data` parameter to pass a QuerySet to the DjangoQuery: 

    qs = Book.objects.filter(name__startswith="B").only('id')
    dq = DQ("(b.name, b.price) Book{id in '@qs_sub'} b", names={"qs_sub": qs})

    qs = Book.objects.filter(name__startswith="B").only('id')
    ids = [rec.id for rec in qs]
    dq = DQ("(b.name, b.price) Book{id in '@qs_sub'} b", names={"qs_sub": ids})

As with QuerySets it is nearly always faster to generate a sub query than use an itemised list. 

Django Subquery and OuterRef
----------------------------

The following do pretty much the same thing:

    # QuerySet
    pubs = Publisher.objects.filter(pk=OuterRef('publisher')).only('pk')
    Book.objects.filter(publisher__in=Subquery(pubs))
    
    # Djaq
    DQ("(p.id) Publisher p", name='pubs')
    DQ("(b.name) Book{publisher in '@pubs'} b")

Obviously, in both cases, you would be filtering Publisher to make it actually useful, but the effect and verbosity can be extrapolated as roughly the same as above.

Order by
--------

You can order_by like this: 

    DQ("(b.id) Book{b.price > 20} b order by (b.name)")
    
Descending order: 

    DQ("(b.id) Book{b.price > 20} b order by -(b.name)")
    
You can use either `+` or `-` for ASC or DESC. 

Count
-----

There are a couple ways to count results. These both return the same thing:

    DQ("(Book.id)").count()
    
    DQ("(count(Book.id)) Book").value()

Datetimes
---------

Datetimes are provided as strings in the iso format that your backend expects, like '2019-01-01 18:00:00'. 

Slicing
-------

You cannot slice a DjangoQuery at this time because this would frustrate a design goal of Djaq to provide the performance advantages of cursor-like behaviour. 

We will probably provide a separate class to provide slice behaviour in the future. But you can already do this: 

    DjangoQuery("...").offset(1000).limit(100).tuples()

Which will provide you with the first hundred results starting from the 1000th record. 

Rewind cursor
-------------

You can rewind the cursor but this is just executing the SQL again: 

    for rec in xq.tuples():
        print(rec)
    
    # now, calling `xq.tuples()` returns nothing
    
    # get fresh cursor
    for rec in xq.rewind().tuples():
        print(rec)

If you call `DjangoQuery.context(data)`, that will effectively rewind the cursor since an entirely new query is created and the implementation currently doesn't care if `data` is the same context as previously supplied.

Implementation Notes
--------------------

The parser for Djaq is kind of a mixed bag. It uses regular expressions, custom character stream processing and mostly Python's Abstract Syntax Tree module. The manner of parsing is not necessarily optimal and I'm no compiler expert by a long shot. But the performance overhead and features seem acceptable at this time. 

To understand available functions for column expressions or filters, if a function is not defined by DjangoQuery, then the function name is passed without further intervention to the underlying SQL. A user can define new functions at any time by adding to the custom functions. Here's an example of adding a regex matching function: 

    DjangoQuery.functions["REGEX"] = "{} ~ {}"

Now find all book names starting with 'B':

    DQ("(b.name) Book{regex(b.name, 'B.*')} b")

Notice, we always want to use upper case for the function name when defining the function. Usage of a function is then case-insensitive. You may wish to make sure you are not over-writing existing functions. "REGEX" already exists, for instance. 

You can also provide a `callable` to DjangoQuery.functions. The callable needs to take two arguments: the function name and a list of positional parameters and it must return SQL as a string that can either represent a column expression or some value expression from the underlying backend. 

#Compare SQLAlchemy, Django QuerySet, Djaq

https://www.pythoncentral.io/overview-sqlalchemys-expression-language-orm-queries/

"Since the Expression Language provides lower-level Python structures that mimic a backend-neutral SQL, it feels almost identical to writing actual SQL but in a Pythonic way."

Django makes similar claims about data access being "Pythonic". I struggle with both of these assertions. In my opinion, there is nothing especially "Pythonic" about the APIs of SQLAlchemy or Django. They are Python APIs but they are not exemplary in their applicaiton of Python which is what "Pythonic" means. 

In contrast, Djaq is the exact inverse of those ORM APIs. It is a language more than an API. And that language is mostly directly expressed as pseudo Python statements. 

#DB Portability

The intent is to provide broad portability comparable to QuerySets. Various steps need to be taken to make Djaq more portable (it will be most compatible at the start with Postgresql). For instance, the ability to access db functions directly could lead to dependence on a particular DB's SQL. But this can be largely mitigated by providing custom functions for all the fuctions that you wish to use. We need to make the custom function feature provide different sets of functions per backend, a planned development. But ultimately the choice to use proprietary functions is something I think should be left to the user. Even with Django QuerySets there are various ways to use proprietary features of a db backend. 

Djaq comparative weaknesses
---------------------------

Just as QuerySets exhibit weaknesses as a result of feature priorities, so does Djaq. But aside from incomplete features, the biggest shortcoming is that it will be missing many things present in the Django API, especially for edge cases and those myriad smaller cases that are only exposed through years of experience. 

* You might find that Querysets are more "composable". You can programmatically build queries based on conditions more easily. The classic use case is building a query based on form submission for search. You iterate over the Request dict, building the query step-by-step. You can do this with Djaq but you might find it more natural with Querysets. See Future for potential solutions in Djaq.

* The DQResult class does not handle m2m fields in any way at this time. TBD. It also does not handle automagic relationship following (by design) or backwards relations. 

* Currently, Djaq is a proof of concept. It has not undergone the rigorous testing required to give confidence it will work as described. You might think, "it is only for SELECT queries, how damaging can that be?". Well, think if a query were to return wrong or unexpected information, like a filter is broader than you expected. You decide how damaging that could be for your application.

* Djaq only handles SELECT queries. It has no functionality for creating or updating data. 

* Djaq does not fit into the Django ecosystem as well as Querysets. For instance, "Querysets" are really several kinds of class that represent lists and other objects. The Django framework is made to work with QuerySets and therefore may offer more options for some operations. 

* All the above examples have been tested and work with Postgresql and to a lesser extent tested with SQLite3. They might work with MySQL, Oracle, etc. Maybe. Obviously, the Django ORM has been extensively tested with all the databases it claims to support. 

Future
------

Things that would be interesting going forward:

* Improve SQL generation 
* A new, separate object type for sliceable results access
* Type coercion and type checking when providing context data, like: `DQ("...").validation_class(myclass).context(data)`
* Direct support for GraphQL
* Mutable Djaq queries based on context data. For instance, removing elements of a query where context data is not provided

Summary
=======

The purpose of Djaq is to provide an *optional* alternative to QuerySets that provides more explicit control over query behaviour and a more natural, Python-based language that is more readable and learnable. Users don't need to choose one or the other. Djaq is just a separate path that might be more beneficial depending on how specific developers wish to work.

